#include "all-header.h"

unsigned char ExitIcon[231] = {
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x8D, 0x89, 0x1D, 0x0D, 0x00, 0x00, 0x00,
	0x06, 0x62, 0x4B, 0x47, 0x44, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xA0,
	0xBD, 0xA7, 0x93, 0x00, 0x00, 0x00, 0x9C, 0x49, 0x44, 0x41, 0x54, 0x38,
	0x8D, 0xED, 0xD1, 0xA1, 0x0A, 0x02, 0x41, 0x14, 0x05, 0xD0, 0x45, 0x44,
	0xB6, 0x99, 0xB5, 0x18, 0xF6, 0x7F, 0xFC, 0x02, 0xBF, 0xC1, 0x62, 0xB7,
	0x59, 0x36, 0x0B, 0xFE, 0x99, 0x68, 0x12, 0x34, 0x9B, 0x2C, 0x26, 0x8F,
	0xC1, 0x41, 0x16, 0x41, 0xDF, 0xAC, 0x5B, 0xF7, 0xC5, 0xE1, 0x72, 0xE6,
	0xCD, 0xDC, 0xA2, 0xE8, 0x07, 0x25, 0xCA, 0xCC, 0xEC, 0x38, 0x27, 0xB4,
	0xC3, 0x01, 0x93, 0x20, 0x57, 0xE3, 0x8E, 0x51, 0x04, 0xCE, 0x70, 0xC2,
	0x11, 0xD3, 0x2F, 0x99, 0x0D, 0x1E, 0x58, 0x86, 0x1B, 0x46, 0x68, 0x6B,
	0xEC, 0x17, 0xFA, 0x37, 0xD6, 0x40, 0x2B, 0x9C, 0xD3, 0x9F, 0x6E, 0x3B,
	0x61, 0x1F, 0xE8, 0xCD, 0x6B, 0xD6, 0x9D, 0xB0, 0x04, 0xD6, 0x69, 0xB3,
	0x6B, 0x4E, 0xFB, 0x11, 0xF6, 0xFE, 0xB3, 0x9C, 0xF6, 0xB3, 0xB1, 0xC6,
	0xD9, 0x7F, 0xE8, 0xAF, 0x36, 0x5B, 0xA3, 0x58, 0x45, 0x6D, 0xA6, 0xA2,
	0x2E, 0xD8, 0x63, 0x18, 0x81, 0x73, 0x2C, 0x32, 0x2E, 0xAE, 0xD2, 0x4B,
	0x06, 0xE1, 0x96, 0xFD, 0xB4, 0x9A, 0x27, 0xC3, 0xBC, 0x12, 0x8A, 0x62,
	0x4A, 0xB6, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE,
	0x42, 0x60, 0x82
};

unsigned char MaximizeIcon[304] = {
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x8D, 0x89, 0x1D, 0x0D, 0x00, 0x00, 0x00,
	0x06, 0x62, 0x4B, 0x47, 0x44, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xA0,
	0xBD, 0xA7, 0x93, 0x00, 0x00, 0x00, 0xE5, 0x49, 0x44, 0x41, 0x54, 0x38,
	0x8D, 0xCD, 0x91, 0xA1, 0x4E, 0x03, 0x41, 0x14, 0x45, 0xCF, 0xDD, 0x4C,
	0x1D, 0x02, 0x70, 0xDB, 0x5F, 0x20, 0x28, 0x0C, 0x49, 0x83, 0xE3, 0x17,
	0x68, 0xBF, 0x02, 0x53, 0x01, 0x0E, 0x85, 0x27, 0xFD, 0x05, 0x64, 0x6B,
	0x2B, 0xD0, 0xA8, 0xEA, 0x0A, 0x0C, 0x09, 0xB2, 0xA6, 0x49, 0xED, 0x0A,
	0x9A, 0xBD, 0x18, 0xB2, 0xD9, 0x90, 0xDD, 0x61, 0xCA, 0xD2, 0xA4, 0x47,
	0xDE, 0xF7, 0xE6, 0xCC, 0xBC, 0x37, 0x70, 0xE8, 0xA8, 0xAD, 0x60, 0xFB,
	0x1E, 0xB8, 0x8B, 0xF5, 0xFC, 0x60, 0x0B, 0xDC, 0x86, 0x48, 0xC3, 0x15,
	0xD0, 0x03, 0x5E, 0x12, 0x85, 0x37, 0xC0, 0x65, 0x4C, 0x58, 0x00, 0x1F,
	0x92, 0x86, 0x29, 0x36, 0xDB, 0x25, 0x40, 0x4C, 0x38, 0x06, 0x8E, 0x12,
	0x5F, 0x57, 0x11, 0x6C, 0x07, 0xE0, 0x1C, 0xC8, 0x5A, 0x6E, 0xBE, 0x68,
	0x88, 0xDF, 0x24, 0x15, 0x8D, 0x46, 0xDB, 0x0F, 0xDE, 0x9D, 0xE7, 0x06,
	0x4F, 0x69, 0xFB, 0x29, 0x00, 0x27, 0x80, 0x81, 0x51, 0xE2, 0x54, 0x13,
	0xE0, 0xB4, 0xAD, 0x58, 0xED, 0x50, 0xD2, 0x2C, 0xC5, 0x66, 0xFB, 0x31,
	0x56, 0x6F, 0xDC, 0x5B, 0x17, 0x62, 0xBF, 0xFC, 0x2B, 0xB6, 0x07, 0x40,
	0xFF, 0x5F, 0x84, 0xB6, 0x33, 0x60, 0x0E, 0x1C, 0xD7, 0xE2, 0xCD, 0x9F,
	0x85, 0x92, 0x4A, 0xDB, 0x67, 0x40, 0xFE, 0x1D, 0x95, 0xC0, 0xB2, 0xD3,
	0xC8, 0x92, 0x56, 0xC0, 0xAA, 0x9E, 0xED, 0xED, 0x53, 0x64, 0x7B, 0x9A,
	0x78, 0x26, 0x07, 0xDE, 0x63, 0xC2, 0x05, 0xB0, 0x06, 0xAE, 0x13, 0x85,
	0x9F, 0xC0, 0x6B, 0x62, 0xEF, 0x01, 0xF2, 0x05, 0x4E, 0x0F, 0x72, 0xC6,
	0x64, 0x4C, 0x80, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
	0xAE, 0x42, 0x60, 0x82
};

unsigned char MinimizeIcon[268] = {
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x8D, 0x89, 0x1D, 0x0D, 0x00, 0x00, 0x00,
	0x06, 0x62, 0x4B, 0x47, 0x44, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xA0,
	0xBD, 0xA7, 0x93, 0x00, 0x00, 0x00, 0xC1, 0x49, 0x44, 0x41, 0x54, 0x38,
	0x8D, 0xED, 0x91, 0x3D, 0x0A, 0xC2, 0x40, 0x14, 0x84, 0xE7, 0x05, 0x0B,
	0xAD, 0xAD, 0x52, 0x5A, 0x0B, 0x41, 0x04, 0x7F, 0xEE, 0x10, 0x4F, 0xE1,
	0x25, 0xBC, 0x80, 0x08, 0x82, 0x10, 0x4F, 0xE0, 0x01, 0x3C, 0x85, 0xA5,
	0xAD, 0x1E, 0x43, 0x8C, 0x7A, 0x02, 0x3F, 0x0B, 0x37, 0x20, 0x21, 0x1B,
	0x62, 0xC0, 0x42, 0xC8, 0x07, 0xDB, 0xBC, 0xD9, 0x99, 0x37, 0xEC, 0x4A,
	0x0D, 0xFF, 0x01, 0xD0, 0x07, 0x7A, 0x25, 0xFA, 0x00, 0x98, 0x16, 0x69,
	0x81, 0xC7, 0x33, 0x93, 0x74, 0x04, 0xA2, 0x82, 0xB0, 0xB1, 0xA4, 0x83,
	0xA4, 0xE1, 0x37, 0x0D, 0x0D, 0x48, 0x80, 0x1B, 0x30, 0xCA, 0x35, 0x4B,
	0x81, 0x4D, 0xE5, 0xB0, 0x5C, 0xF0, 0x12, 0xB8, 0x03, 0x13, 0x20, 0x02,
	0xAE, 0x40, 0x52, 0xC5, 0x18, 0x00, 0x5D, 0x8F, 0xB6, 0x02, 0x1E, 0xC0,
	0x05, 0xD8, 0x7A, 0xEE, 0x74, 0x81, 0xE0, 0x73, 0x10, 0x03, 0xA7, 0x92,
	0x85, 0x0B, 0x17, 0x6C, 0x1E, 0xFD, 0x0C, 0xC4, 0x92, 0xD4, 0x72, 0xB3,
	0x8E, 0x3B, 0x85, 0x98, 0xD9, 0xDA, 0xA7, 0x39, 0xDA, 0x99, 0xDF, 0xF7,
	0xCB, 0xB5, 0xC9, 0x1A, 0x22, 0x29, 0x04, 0xF6, 0x35, 0x73, 0x42, 0x97,
	0x21, 0x93, 0xDE, 0x8F, 0x2A, 0x69, 0xAE, 0xFA, 0x8D, 0x9F, 0x92, 0x76,
	0x66, 0x96, 0xD6, 0xF4, 0x37, 0xFC, 0x92, 0x17, 0xCB, 0x99, 0x82, 0x4C,
	0x9A, 0x1C, 0xD7, 0x39, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
	0xAE, 0x42, 0x60, 0x82
};


static void DebugGL(
    GLenum source,
    GLenum type,
    GLuint id,
    GLenum severity,
    GLsizei length,
    const GLchar *message,
    const void *userParam
){

    std::cout << message << "\n";

}

// to set win resize
static void OnResize(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    GetClientRect(hWnd, &rect);
    InvalidateRect(hWnd, NULL, TRUE);
}

// to get mouse info
static ImGuiMouseSource GetMouseSourceFromMessageExtraInfo()
{
    LPARAM extra_info = ::GetMessageExtraInfo();
    if ((extra_info & 0xFFFFFF80) == 0xFF515700)
        return ImGuiMouseSource_Pen;
    if ((extra_info & 0xFFFFFF80) == 0xFF515780)
        return ImGuiMouseSource_TouchScreen;
    return ImGuiMouseSource_Mouse;
}
bool isCaptionMoved = true;
static void isCaptionDragged(bool &isHover)
{
    isHover = isCaptionMoved;
}

LONG_PTR prevProc;
/**
 * @brief set custom window procedure to hide window native caption
 *
 * @param Window
 * @param Message
 * @param wParam
 * @param lParam
 * @return LRESULT
 */
static LRESULT CALLBACK WindowProcedure(HWND Window, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message)
    {
    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONUP:
    case WM_XBUTTONDOWN:
    case WM_XBUTTONDBLCLK:
    case WM_XBUTTONUP:
        ImGui::GetIO().AddMouseSourceEvent(GetMouseSourceFromMessageExtraInfo());
        break;
    case WM_NCHITTEST:
    {
        // Expand the hit test area for resizing
        const int borderWidth = 11; // Adjust this value to control the hit test area size

        POINTS mousePos = MAKEPOINTS(lParam);
        POINT clientMousePos = {mousePos.x, mousePos.y};
        ScreenToClient(Window, &clientMousePos);

        RECT windowRect;
        GetClientRect(Window, &windowRect);

        if (clientMousePos.y >= windowRect.bottom - borderWidth)
        {
            if (clientMousePos.x <= borderWidth)
                return HTBOTTOMLEFT;
            else if (clientMousePos.x >= windowRect.right - borderWidth)
                return HTBOTTOMRIGHT;
            else
                return HTBOTTOM;
        }
        else if (clientMousePos.y <= borderWidth)
        {
            if (clientMousePos.x <= borderWidth)
                return HTTOPLEFT;
            else if (clientMousePos.x >= windowRect.right - borderWidth)
                return HTTOPRIGHT;
            else
                return HTTOP;
        }
        else if (clientMousePos.x <= borderWidth)
        {
            return HTLEFT;
        }
        else if (clientMousePos.x >= windowRect.right - borderWidth)
        {
            return HTRIGHT;
        }

        // if (clientMousePos.x >= windowRect.left && clientMousePos.x <= (windowRect.right - windowRect.left) && clientMousePos.y >= windowRect.top && clientMousePos.y <= windowRect.top + titleBarHeight)
        // {
        //     return HTCAPTION;
        // }

        bool isMove = false;
        isCaptionDragged(isMove);
        if(isMove){
            return HTCAPTION;
        }

        return HTCLIENT;
    }
    case WM_NCCALCSIZE:
    {
        // Remove the window's standard sizing border
        if (wParam == TRUE && lParam != FALSE)
        {
            NCCALCSIZE_PARAMS *pParams = reinterpret_cast<NCCALCSIZE_PARAMS *>(lParam);
            pParams->rgrc[0].top += 0;
            pParams->rgrc[0].right += 0;
            pParams->rgrc[0].bottom += 0;
            pParams->rgrc[0].left += 0;
        }
        return 0;
    }
    case WM_ENTERSIZEMOVE:
        break;
    case WM_EXITSIZEMOVE:
        break;
    case WM_CLOSE:
        DestroyWindow(Window);
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_SIZE:
        OnResize(Window, Message, wParam, lParam);
        break;
    case WM_NCACTIVATE:
    case WM_NCPAINT:
        return TRUE;
    }

    return ::CallWindowProc((WNDPROC)prevProc, Window, Message, wParam, lParam);
}


static void resize_callback(GLFWwindow* app, int width, int height){
    // glViewport(0,0,width,height);
    // glfwSwapBuffers(app);
}
std::function<void()> render;
static void refresh_callback(GLFWwindow* app){
    render();
}

class DApp
{
public:
    virtual void OnSetup(ImGuiIO& io){};
    virtual void RenderContent(ImGuiIO& io){};
    virtual ~DApp(){};
    DApp(){};
    DApp(const DApp &app) = delete;
    DApp &operator=(const DApp &app) = delete;

    float titleBarHeight = 0.0f;
    double width = 0;
    double height = 0;
    double fontSize = 0;
    bool customTitleBar = false;
    bool showDemoWindow = false;
    const char* title = nullptr;
    GLFWwindow* window;
    ImFont* PoppinsFontText;
    ImFont* PoppinsFontText20Px;
    ImFont* PoppinsFontText25Px;
    ImFont* PoppinsFontText30Px;
    ImFont* PoppinsFontText40Px;
    ImFont* MaterialDesignFontIcon;

private:

    // for titlebar
    ImVec2 padding{}, min{}, max{}, size{};
    bool isHovered = false, isDrag = false;
    std::function<void()> titleBarUtility[3]{};

    void disableTitlebar(GLFWwindow *window){
        HWND MainWindow = glfwGetWin32Window(window);
        DWORD Style = GetWindowLongPtr(MainWindow, GWL_STYLE);
        Style &=
            ~WS_CAPTION & ~WS_SYSMENU & ~WS_THICKFRAME & ~WS_BORDER;
        SetWindowLongPtr(MainWindow, GWL_STYLE, Style);
        RECT windowRect;
        GetWindowRect(MainWindow, &windowRect);
        int width = windowRect.right - windowRect.left;
        int height = windowRect.bottom - windowRect.top;
        prevProc = GetWindowLongPtr(MainWindow, GWLP_WNDPROC);
        (WNDPROC) SetWindowLongPtr(MainWindow, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(WindowProcedure));
        SetWindowPos(MainWindow, NULL, windowRect.left, windowRect.top, width, height, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
    }

    void DrawTitleBar(Texture* menuBarIcon,std::function<void()>* menuBarHandler){
        this->padding = ImVec2(0.0f, 15.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, this->padding);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize,0.0f);
        if (ImGui::BeginMainMenuBar())
        {

            this->min = ImGui::GetItemRectMin();
            this->max = ImGui::GetItemRectMax();
            this->fontSize = ImGui::GetFontSize();
            this->size = ImGui::GetItemRectSize();
            float MenuHeight = this->max.y + fontSize + 2 * this->padding.y;
            this->titleBarHeight = MenuHeight - min.y;

            ImGui::Columns(2, "title-bar-columns", true);
            ImGui::SetColumnWidth(0, (this->max.x - this->min.x) - 150);
            ImGui::InvisibleButton(
                "",
            ImVec2((this->max.x - this->min.x) - 150, this->titleBarHeight));
            isCaptionMoved = ImGui::IsItemHovered();
            ImGui::SetCursorPos(ImVec2(100, 0));
            ImGui::Text(this->title);
            ImGui::NextColumn();
            ImGui::SetColumnWidth(1, 150);
            ImGui::PushStyleColor(
            ImGuiCol_Button,
            ImVec4(1.0f, 1.0f, 1.0f, 0.0f));
            ImGui::PushStyleColor(
            ImGuiCol_ButtonHovered,
            ImVec4(1.0f, 1.0f, 1.0f, 0.1f));
            ImGui::PushStyleColor(
            ImGuiCol_ButtonActive,
            ImVec4(1.0f, 1.0f, 1.0f, 0.3f));
            for (int i = 0; i < 3; i++)
            { 
                if(ImGui::ImageButton(
                    (void*)(intptr_t)menuBarIcon[i].ID,
                    ImVec2(50.0f,this->titleBarHeight),// size
                    ImVec2(-(50.0f/20.0f) + 0.8f,0),
                    ImVec2(50.0f/20.0f,(this->titleBarHeight/20.0f) + 0.8f)
                )){
                    menuBarHandler[i]();
                };
                
                if (i < 2)
                    ImGui::SameLine();
            }

            ImGui::PopStyleColor(3);
            ImGui::Columns(1);
            ImGui::EndMainMenuBar();
            ImGui::PopStyleVar(4);
        }
    };

    void DrawTitleBar(std::string* menuBarIcon,std::function<void()>* menuBarHandler){
        this->padding = ImVec2(0.0f, 15.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, this->padding);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize,0.0f);
        if (ImGui::BeginMainMenuBar())
        {

            this->min = ImGui::GetItemRectMin();
            this->max = ImGui::GetItemRectMax();
            this->fontSize = ImGui::GetFontSize();
            this->size = ImGui::GetItemRectSize();
            float MenuHeight = this->max.y + fontSize + 2 * this->padding.y;
            this->titleBarHeight = MenuHeight - min.y;

            ImGui::Columns(2, "title-bar-columns", true);
            ImGui::SetColumnWidth(0, (this->max.x - this->min.x) - 150);
            ImGui::InvisibleButton("",ImVec2((this->max.x - this->min.x) - 150, this->titleBarHeight));
            isCaptionMoved = ImGui::IsItemHovered();
            
            ImGui::SetCursorPos({
                (float)ImGui::GetColumnWidth(0)/2 - (float)(ImGui::CalcTextSize(this->title).x * 0.5),
                0
            });
            ImGui::Text(this->title);
            ImGui::NextColumn();
            
            ImGui::SetColumnWidth(1, 150);
            ImGui::PushStyleColor(ImGuiCol_Button,ImVec4(1.0f, 1.0f, 1.0f, 0.0f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered,ImVec4(1.0f, 1.0f, 1.0f, 0.1f));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive,ImVec4(1.0f, 1.0f, 1.0f, 0.3f));
            
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, {0,0});
            for (int i = 0; i < 3; i++)
            { 
                ImGuiStyle& style = ImGui::GetStyle();
                ImVec2 defaultButtonTextAlign = style.ButtonTextAlign;
                ImVec2 fontSize = ImGui::CalcTextSize(menuBarIcon[i].c_str());
                style.ButtonTextAlign = ImVec2(0.5f,0.5f + (fontSize.y/this->titleBarHeight)/2);
                ImGui::PushFont(this->MaterialDesignFontIcon);
                if(ImGui::Button(
                    menuBarIcon[i].c_str(),
                    ImVec2(50.0f,this->titleBarHeight)// size
                )){
                    menuBarHandler[i]();
                };
                style.ButtonTextAlign = defaultButtonTextAlign;
                if (i < 2)
                    ImGui::SameLine();
                ImGui::PopFont();
            }
            
            ImGui::PopStyleColor(3);
            ImGui::Columns(1);
            ImGui::EndMainMenuBar();
            ImGui::PopStyleVar(5);
        }
    };

public:
    void Start()
    {

        GLFWwindow *app;
        if (!glfwInit())
        {
            std::cout << "Failed to init glfw\n";
            exit(EXIT_FAILURE);
        }
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        app = glfwCreateWindow(this->width, this->height, this->title, nullptr, nullptr);
        this->window = app;
        

        if(this->customTitleBar){
            disableTitlebar(app);
        }
        glfwMakeContextCurrent(app);
        glfwSwapInterval(1);

        // Setup Dear ImGui context
        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        ImGuiIO& io = ImGui::GetIO();
        io.IniFilename = "App.ini";
        (void)io;
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls
        io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;     // Enable Docking
        io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;   // Enable Multi-Viewport / Platform Windows
        // io.ConfigViewportsNoAutoMerge = true;
        // io.ConfigViewportsNoTaskBarIcon = true;
        
        glfwSetWindowRefreshCallback(this->window,refresh_callback);
        glfwSetWindowSizeCallback(this->window, resize_callback);
        // When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.
        ImGuiStyle &style = ImGui::GetStyle();
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            style.WindowRounding = 3.0f;
            style.Colors[ImGuiCol_WindowBg].w = 1.0f;
        }
        // Setup Platform/Renderer backends
        ImGui_ImplGlfw_InitForOpenGL(app, true);
        ImGui_ImplOpenGL3_Init();
        if (glewInit() != GLEW_OK)
        {
            std::cout << "Failed to init glew\n";
            glfwTerminate();
            exit(EXIT_FAILURE);
        }

        glEnable(GL_DEBUG_OUTPUT);
        glDebugMessageCallback(DebugGL,nullptr);
        int t;
        glGetIntegerv(GL_MAX_TEXTURE_UNITS, &t);
        std::cout << "MAX Total unit of texture : " << t << "\n";
        std::cout << "OpenGL Version " << glGetString(GL_VERSION) << "\n";

        GLuint shader = createShader(
            __current_path + "/../Shader/StandardVertexShader.glsl",
            __current_path + "/../Shader/StandardFragmentShader.glsl");
        glUseProgram(shader);

        int display_w, display_h;
        glfwGetWindowPos(app, &display_w, &display_h);
        
        this->PoppinsFontText = io.Fonts->AddFontFromMemoryTTF(PoppinsFont,sizeof(PoppinsFont),18.0f);
        this->PoppinsFontText20Px = io.Fonts->AddFontFromMemoryTTF(PoppinsFont,sizeof(PoppinsFont),20.0f);
        this->PoppinsFontText25Px = io.Fonts->AddFontFromMemoryTTF(PoppinsFont,sizeof(PoppinsFont),25.0f);
        this->PoppinsFontText30Px = io.Fonts->AddFontFromMemoryTTF(PoppinsFont,sizeof(PoppinsFont),30.0f);
        this->PoppinsFontText40Px = io.Fonts->AddFontFromMemoryTTF(PoppinsFont,sizeof(PoppinsFont),40.0f);
        // io.Fonts->Build();
        // Load font from material design
        float baseFontSize = 20.0f; // 13.0f is the size of the default font. Change to the font size you use.

        // merge in icons from Material Design
        static const ImWchar icons_ranges[] = { ICON_MIN_MD, ICON_MAX_16_MD, 0 };
        ImFontConfig icons_config; 
        icons_config.MergeMode = true;
        icons_config.OversampleH = 3;
        icons_config.OversampleV = 3;
        icons_config.PixelSnapH = true; 
        this->MaterialDesignFontIcon = io.Fonts->AddFontFromMemoryTTF( MaterialDesignIcon,sizeof(MaterialDesignIcon), baseFontSize, &icons_config, icons_ranges );

        std::function<void()> menuBarHandler[3];
        menuBarHandler[0] = [&]()->void{
            glfwIconifyWindow(app);
        };

        // GLFWmonitor* primaryMonitor = glfwGetPrimaryMonitor();
        // int x,y,w,h;
        menuBarHandler[1] = [&]()->void{
            glfwMaximizeWindow(app);
            // glfwGetMonitorWorkarea(primaryMonitor,&x,&y,&w,&h);
            // glfwSetWindowPos(this->window,0,0);
            // glfwSetWindowSize(this->window,w,h);
        };
        menuBarHandler[2] = [&]()->void{
            glfwTerminate();
            exit(EXIT_SUCCESS);
        };

        // use this if you want to use custom image as a menubar icon
        // Texture menuBarIcon[3];
        // menuBarIcon[0].Load<GL_CLAMP_TO_BORDER>(MinimizeIcon,1,sizeof(MinimizeIcon)/sizeof(char));
        // menuBarIcon[1].Load<GL_CLAMP_TO_BORDER>(MaximizeIcon,0,sizeof(MaximizeIcon)/sizeof(char));
        // menuBarIcon[2].Load<GL_CLAMP_TO_BORDER>(ExitIcon,2,sizeof(ExitIcon)/sizeof(char));

        // default menubar icon using google material design icon
        std::string menuBarIcon[3] = {ICON_MD_REMOVE,ICON_MD_FULLSCREEN,ICON_MD_CLOSE};
        this->OnSetup(io);

        render = [&]()->void{
            ImGui_ImplOpenGL3_NewFrame();
            ImGui_ImplGlfw_NewFrame();
            ImGui::NewFrame();
            {
                if(this->customTitleBar){
                    this->DrawTitleBar(menuBarIcon,menuBarHandler);
                }
                this->RenderContent(io);
            }

            if(this->showDemoWindow){
                ImGui::ShowDemoWindow();
            }
            ImGui::Render();
            ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

            // Update and Render additional Platform Windows
            // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
            //  For this specific demo app we could also call glfwMakeContextCurrent(window) directly)
            if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
            {
                GLFWwindow *backup_current_context = glfwGetCurrentContext();
                ImGui::UpdatePlatformWindows();
                ImGui::RenderPlatformWindowsDefault();
                glfwMakeContextCurrent(backup_current_context);
            }

            glfwSwapBuffers(app);
        };

        while (!glfwWindowShouldClose(app))
        {
            glClear(GL_COLOR_BUFFER_BIT);
            ImGui_ImplOpenGL3_NewFrame();
            ImGui_ImplGlfw_NewFrame();
            ImGui::NewFrame();
            {
                if(this->customTitleBar){
                    this->DrawTitleBar(menuBarIcon,menuBarHandler);
                }
                this->RenderContent(io);
            }

            if(this->showDemoWindow){
                ImGui::ShowDemoWindow();
            }
            
            ImGui::Render();
            ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

            // Update and Render additional Platform Windows
            // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
            //  For this specific demo app we could also call glfwMakeContextCurrent(window) directly)
            if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
            {
                GLFWwindow *backup_current_context = glfwGetCurrentContext();
                ImGui::UpdatePlatformWindows();
                ImGui::RenderPlatformWindowsDefault();
                glfwMakeContextCurrent(backup_current_context);
            }

            glfwSwapBuffers(app);
            glfwPollEvents();
        }
        glfwTerminate();
    };
};
